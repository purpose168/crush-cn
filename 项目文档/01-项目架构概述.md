# 项目架构概述

## 文档信息

- **文档版本**: v1.0
- **创建日期**: 2026-02-12
- **最后更新**: 2026-02-12
- **作者**: 工程文档专家
- **联系方式**: purpose168@outlook.com

---

## 1. 系统整体架构设计

### 1.1 架构模式选择

Crush 项目采用**分层架构模式**与**事件驱动架构**相结合的设计理念，确保系统的可扩展性、可维护性和高性能。

#### 架构模式选择依据

1. **分层架构模式**
   - **表示层（UI层）**: 负责终端用户界面的渲染和交互
   - **应用层（App层）**: 协调各服务组件，管理应用生命周期
   - **业务逻辑层（Agent层）**: 实现 AI 代理的核心业务逻辑
   - **服务层（Service层）**: 提供会话管理、消息处理、权限控制等服务
   - **数据访问层（DAL层）**: 封装数据库操作，提供数据持久化能力
   - **基础设施层（Infrastructure层）**: 提供 LSP、MCP、Shell 等外部集成

2. **事件驱动架构**
   - 采用发布-订阅模式实现组件间的松耦合通信
   - 使用通道（Channel）进行异步消息传递
   - 支持实时状态更新和事件通知

### 1.2 核心组件关系图

```
┌─────────────────────────────────────────────────────────────────┐
│                          用户界面层 (UI)                          │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐       │
│  │  Chat UI │  │ Model UI │  │  List UI │  │  Diff UI │       │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘       │
└─────────────────────────────────────────────────────────────────┘
                              │
                              │ BubbleTea 框架
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                         应用层 (App)                             │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │                    App 核心协调器                          │  │
│  │  • 会话管理  • 消息路由  • 事件分发  • 生命周期管理        │  │
│  └──────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                       业务逻辑层 (Agent)                         │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │                  Agent 协调器                              │  │
│  │  • 会话代理  • 模型管理  • 工具调用  • 自动摘要           │  │
│  └──────────────────────────────────────────────────────────┘  │
│  ┌────────────┐  ┌────────────┐  ┌────────────┐              │
│  │ 大型模型   │  │ 小型模型   │  │  工具集    │              │
│  └────────────┘  └────────────┘  └────────────┘              │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                        服务层 (Services)                         │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐       │
│  │ Session  │  │ Message  │  │Permission│  │ History  │       │
│  │ Service  │  │ Service  │  │ Service  │  │ Service  │       │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘       │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐                     │
│  │FileTrack │  │   LSP    │  │   MCP    │                     │
│  │ Service  │  │ Manager  │  │ Manager  │                     │
│  └──────────┘  └──────────┘  └──────────┘                     │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      数据访问层 (DAL)                            │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │              数据库访问层 (sqlc 生成)                       │  │
│  │  • Sessions  • Messages  • Files  • Stats                │  │
│  └──────────────────────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │                  SQLite 数据库                             │  │
│  └──────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    基础设施层 (Infrastructure)                   │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐       │
│  │   LSP    │  │   MCP    │  │  Shell   │  │  OAuth   │       │
│  │ Client   │  │ Client   │  │ Manager  │  │ Provider │       │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘       │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐                     │
│  │  Config  │  │   Log    │  │  Event   │                     │
│  │ Resolver │  │  System  │  │  System  │                     │
│  └──────────┘  └──────────┘  └──────────┘                     │
└─────────────────────────────────────────────────────────────────┘
```

### 1.3 核心组件说明

#### 1.3.1 应用层（App Layer）

**核心职责**:
- 应用程序生命周期管理
- 服务组件初始化和协调
- 事件分发和订阅管理
- 优雅关闭和资源清理

**关键组件**:
- `App` 结构体: 应用程序核心协调器
- `UpdateAvailableMsg`: 版本更新通知
- 事件订阅系统: 实现组件间通信

**代码位置**: [internal/app/app.go](file:///home/pps/github/kunwu-agents/crush-cn/internal/app/app.go)

#### 1.3.2 业务逻辑层（Agent Layer）

**核心职责**:
- AI 代理会话管理
- 多模型协调（大型模型/小型模型）
- 工具调用和执行
- 自动摘要和上下文管理
- 消息队列和请求取消

**关键组件**:
- `Coordinator`: 代理协调器
- `SessionAgent`: 会话代理接口
- `Model`: 模型封装
- 工具集: 包括 bash、edit、grep、ls 等内置工具

**代码位置**: [internal/agent/agent.go](file:///home/pps/github/kunwu-agents/crush-cn/internal/agent/agent.go)

#### 1.3.3 服务层（Service Layer）

**核心服务**:

1. **Session Service**: 会话管理服务
   - 创建、查询、更新、删除会话
   - 会话状态管理
   - Todo 列表管理

2. **Message Service**: 消息管理服务
   - 消息创建和更新
   - 消息列表查询
   - 消息内容管理

3. **Permission Service**: 权限管理服务
   - 工具权限控制
   - 权限请求和审批
   - YOLO 模式支持

4. **History Service**: 历史记录服务
   - 文件操作历史
   - 文件读取跟踪

5. **FileTracker Service**: 文件跟踪服务
   - 文件变更跟踪
   - 文件状态管理

6. **LSP Manager**: 语言服务器协议管理器
   - LSP 客户端生命周期管理
   - 诊断信息收集
   - 代码引用查询

7. **MCP Manager**: 模型上下文协议管理器
   - MCP 服务器连接管理
   - 工具和资源发现
   - 动态工具注册

#### 1.3.4 数据访问层（DAL）

**技术选型**:
- **数据库**: SQLite（嵌入式数据库）
- **ORM**: sqlc（类型安全的 SQL 代码生成）
- **迁移工具**: goose

**数据模型**:
- `sessions`: 会话表
- `messages`: 消息表
- `files`: 文件表
- `read_files`: 已读文件表
- `stats`: 统计表

**代码位置**: [internal/db/](file:///home/pps/github/kunwu-agents/crush-cn/internal/db/)

#### 1.3.5 基础设施层（Infrastructure）

**核心组件**:

1. **LSP Client**: 语言服务器协议客户端
   - 支持 gopls、typescript-language-server、nil 等
   - 提供代码补全、诊断、引用查询

2. **MCP Client**: 模型上下文协议客户端
   - 支持 stdio、HTTP、SSE 三种传输方式
   - 动态工具发现和注册

3. **Shell Manager**: Shell 进程管理器
   - 后台进程管理
   - 命令执行和输出捕获

4. **OAuth Provider**: OAuth 认证提供者
   - 支持 GitHub Copilot、Hyper 等提供商
   - Token 刷新和管理

5. **Config Resolver**: 配置解析器
   - 环境变量解析
   - 配置文件加载和验证

6. **Log System**: 日志系统
   - 结构化日志记录
   - 日志轮转和归档

7. **Event System**: 事件系统
   - 发布-订阅模式
   - 事件标识和路由

---

## 2. 关键技术决策说明

### 2.1 编程语言选择：Go

**选择理由**:
1. **并发性能**: Go 的 goroutine 和 channel 天然适合处理并发任务
2. **跨平台支持**: 编译为单一二进制文件，易于分发和部署
3. **标准库丰富**: 内置 HTTP 服务器、JSON 处理、测试框架等
4. **性能优异**: 编译型语言，运行效率高，内存占用低
5. **开发效率**: 语法简洁，编译速度快，开发体验好

### 2.2 UI 框架选择：BubbleTea

**选择理由**:
1. **函数式设计**: 基于 Elm 架构，状态管理清晰
2. **跨平台**: 支持所有主流操作系统和终端
3. **组件丰富**: Charm 生态系统提供大量可复用组件
4. **性能优秀**: 增量渲染，响应迅速
5. **社区活跃**: 文档完善，示例丰富

**核心依赖**:
- `charm.land/bubbletea/v2`: 核心框架
- `charm.land/bubbles/v2`: UI 组件库
- `charm.land/lipgloss/v2`: 样式和布局
- `charm.land/glamour/v2`: Markdown 渲染

### 2.3 数据库选择：SQLite

**选择理由**:
1. **嵌入式**: 无需独立数据库服务器，简化部署
2. **零配置**: 无需安装和配置，开箱即用
3. **性能优秀**: 对于单用户应用性能足够
4. **可靠性**: 事务支持，数据一致性好
5. **跨平台**: 数据库文件可在不同操作系统间迁移

**数据库驱动**:
- `modernc.org/sqlite`: 纯 Go 实现，无 CGO 依赖
- `github.com/ncruces/go-sqlite3`: WASM 实现，性能优秀

### 2.4 AI 模型集成：Fantasy 框架

**选择理由**:
1. **统一接口**: 提供统一的 AI 模型调用接口
2. **多提供商支持**: 支持 OpenAI、Anthropic、Google、Azure 等
3. **流式响应**: 支持流式输出，实时显示
4. **工具调用**: 内置工具调用机制
5. **缓存优化**: 支持提示缓存，降低成本

**支持的提供商**:
- OpenAI (GPT-4, GPT-4o, o1, o3)
- Anthropic (Claude 3.5, Claude 4)
- Google (Gemini)
- Azure OpenAI
- Amazon Bedrock
- OpenRouter
- Vercel AI Gateway
- 本地模型 (Ollama, LM Studio)

### 2.5 代码生成工具：sqlc

**选择理由**:
1. **类型安全**: 生成类型安全的 Go 代码
2. **SQL 优先**: 直接编写 SQL，无需学习 ORM DSL
3. **性能优秀**: 无反射，运行效率高
4. **开发体验**: IDE 支持好，自动补全和类型检查
5. **维护简单**: SQL 和 Go 代码分离，易于维护

### 2.6 配置管理：JSON Schema

**选择理由**:
1. **标准化**: JSON Schema 是业界标准
2. **验证**: 自动验证配置文件格式
3. **IDE 支持**: 主流 IDE 都支持 JSON Schema
4. **文档化**: Schema 本身就是文档
5. **扩展性**: 易于添加新配置项

---

## 3. 架构演进规划

### 3.1 当前架构特点

**优势**:
1. **模块化**: 各层职责清晰，耦合度低
2. **可扩展**: 易于添加新的工具、提供商和功能
3. **可测试**: 依赖注入，易于单元测试
4. **性能**: 并发处理，响应迅速
5. **可维护**: 代码组织清晰，文档完善

**挑战**:
1. **状态管理**: 随着功能增加，状态管理复杂度上升
2. **错误处理**: 异步操作的错误处理需要优化
3. **性能监控**: 缺乏完善的性能监控机制
4. **测试覆盖**: 部分模块测试覆盖率不足

### 3.2 短期演进计划（3-6个月）

#### 3.2.1 性能优化

1. **数据库优化**
   - 添加索引优化查询性能
   - 实现消息分页加载
   - 优化数据库连接池

2. **内存优化**
   - 实现消息流式处理，减少内存占用
   - 优化大文件处理
   - 添加内存使用监控

3. **并发优化**
   - 优化 goroutine 使用
   - 减少锁竞争
   - 实现更细粒度的并发控制

#### 3.2.2 功能增强

1. **多会话支持**
   - 支持同时运行多个会话
   - 会话间切换和共享
   - 会话模板和预设

2. **插件系统**
   - 设计插件 API
   - 支持第三方插件
   - 插件市场和分发

3. **协作功能**
   - 多用户协作
   - 会话共享和导出
   - 团队工作区

### 3.3 中期演进计划（6-12个月）

#### 3.3.1 架构重构

1. **微服务化**
   - 将 Agent 服务独立部署
   - 实现服务间通信
   - 支持分布式部署

2. **插件架构**
   - 完善插件系统
   - 支持热加载
   - 插件沙箱隔离

3. **事件溯源**
   - 实现事件溯源模式
   - 支持状态回放
   - 审计日志

#### 3.3.2 生态系统

1. **SDK 开发**
   - 提供 Go SDK
   - 提供 Python SDK
   - 提供 JavaScript SDK

2. **API 网关**
   - 提供 RESTful API
   - 提供 GraphQL API
   - WebSocket 支持

3. **云服务**
   - 云端会话存储
   - 云端模型代理
   - 云端协作服务

### 3.4 长期演进计划（1-2年）

#### 3.4.1 智能化

1. **智能代理**
   - 多代理协作
   - 自主任务规划
   - 智能代码生成

2. **知识图谱**
   - 项目知识库
   - 代码语义理解
   - 智能推荐

3. **自适应优化**
   - 自动性能调优
   - 智能缓存策略
   - 动态资源分配

#### 3.4.2 平台化

1. **企业版**
   - 多租户支持
   - 权限管理
   - 审计和合规

2. **云原生**
   - Kubernetes 部署
   - 服务网格
   - 可观测性

3. **国际化**
   - 多语言支持
   - 本地化部署
   - 合规性认证

---

## 4. 架构设计原则

### 4.1 SOLID 原则应用

1. **单一职责原则（SRP）**
   - 每个模块只负责一个功能
   - 例如：Session Service 只负责会话管理

2. **开放封闭原则（OCP）**
   - 对扩展开放，对修改封闭
   - 例如：通过接口定义工具，易于添加新工具

3. **里氏替换原则（LSP）**
   - 子类可以替换父类
   - 例如：所有 Provider 实现相同的接口

4. **接口隔离原则（ISP）**
   - 接口最小化
   - 例如：SessionAgent 接口只包含必要的方法

5. **依赖倒置原则（DIP）**
   - 依赖抽象而非具体实现
   - 例如：通过依赖注入使用服务

### 4.2 设计模式应用

1. **工厂模式**: 创建不同类型的 Provider
2. **策略模式**: 不同工具的执行策略
3. **观察者模式**: 事件发布订阅系统
4. **装饰器模式**: 中间件链
5. **单例模式**: 配置管理器
6. **适配器模式**: LSP/MCP 客户端适配

### 4.3 并发设计原则

1. **不要通过共享内存来通信，而要通过通信来共享内存**
   - 使用 channel 进行 goroutine 间通信
   - 避免共享状态

2. **最小化锁的使用**
   - 使用 sync.Map 替代 map + mutex
   - 使用原子操作

3. **避免 goroutine 泄漏**
   - 使用 context 进行取消
   - 使用 defer 清理资源

4. **合理设置缓冲区大小**
   - 根据实际需求设置 channel 缓冲区
   - 避免无限制的缓冲

---

## 5. 架构风险评估

### 5.1 技术风险

| 风险项 | 风险等级 | 影响 | 缓解措施 |
|--------|---------|------|----------|
| AI 模型 API 变更 | 中 | 功能受影响 | 抽象层隔离，快速适配 |
| SQLite 性能瓶颈 | 低 | 单用户场景影响小 | 监控性能，必要时迁移 |
| 依赖库漏洞 | 中 | 安全风险 | 定期更新依赖，安全扫描 |
| 并发竞争条件 | 中 | 数据不一致 | 代码审查，竞态检测 |

### 5.2 架构风险

| 风险项 | 风险等级 | 影响 | 缓解措施 |
|--------|---------|------|----------|
| 状态管理复杂度 | 中 | 维护困难 | 引入状态管理库 |
| 测试覆盖不足 | 中 | 质量风险 | 提高测试覆盖率 |
| 文档不完善 | 低 | 上手困难 | 持续完善文档 |
| 性能监控缺失 | 中 | 问题难定位 | 添加监控指标 |

### 5.3 业务风险

| 风险项 | 风险等级 | 影响 | 缓解措施 |
|--------|---------|------|----------|
| AI 成本控制 | 高 | 成本超支 | 缓存优化，成本监控 |
| 用户数据隐私 | 高 | 合规风险 | 本地存储，加密敏感数据 |
| 竞品压力 | 中 | 市场份额 | 持续创新，提升体验 |

---

## 6. 总结

Crush 项目采用了现代化的分层架构和事件驱动设计，充分利用了 Go 语言的并发特性和 Charm 生态系统的 UI 组件。架构设计遵循 SOLID 原则，具有良好的可扩展性、可维护性和可测试性。

通过清晰的模块划分和职责分离，系统各组件可以独立演进，降低了维护成本。事件驱动架构实现了组件间的松耦合，提高了系统的灵活性和响应速度。

未来，项目将沿着性能优化、功能增强、架构重构和平台化的方向持续演进，逐步实现智能化和平台化的目标，为用户提供更加强大和便捷的 AI 辅助编程体验。
